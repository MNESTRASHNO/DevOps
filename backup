import paramiko


import logging
import re

from telegram import Update, ForceReply, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, ConversationHandler


import logging
import psycopg2
from psycopg2 import Error

TOKEN = "6993763154:AAG9DRGWFYaeqD1QrdLn1pmrsIuErjU9eP4"



# Подключаем логирование
logging.basicConfig(
    filename='logfile.txt', format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)

logger = logging.getLogger(__name__)


#Подключаемся по ssh
host = '172.16.184.148'
port = '22'
username = 'al1'
password = '1'

client = paramiko.SSHClient()
client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
client.connect(hostname=host, username=username, password=password, port=port)


#PSYCOP2 
params = {
    "dbname": "db_ptstart",
    "user": "postgres",
    "password": "Qq12345",
    "host": "172.16.184.148",
    "port": "5432"
}

conn = psycopg2.connect(**params) # подключение к бд
cur = conn.cursor() # создаем курсор


def getEmails(update: Update, context):
    
    
    # Выполнение SQL-запроса
    cur.execute("SELECT * FROM mail;")

    # Получение всех результатов запроса
    rows = cur.fetchall()

    update.message.reply_text(rows)
    

def getPhone(update: Update, context):

    
    # Выполнение SQL-запроса
    cur.execute("SELECT * FROM phone;")

    # Получение всех результатов запроса
    rows = cur.fetchall()

    update.message.reply_text(rows)
    


def getreleaseCommand(update: Update, context):
    stdin, stdout, stderr = client.exec_command('lsb_release -a') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    release_info = data.decode("utf-8")  # декодируем данные в строку

    response = "Информация о выпуске Linux:\n"
    lines = release_info.split("\n")  # разделяем строки
    for line in lines:
        if len(line) > 0:
            response += f"- {line}\n"  # добавляем каждую строку с префиксом "-" для удобства чтения

    update.message.reply_text(response)  # отправляем красиво отформатированный текст
    
def getrepllogs(update: Update, context):
    stdin, stdout, stderr = client.exec_command('cat /var/log/postgresql/postgresql-15-main.log | tail') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getUnameCommand(update: Update, context):
    stdin, stdout, stderr = client.exec_command('uname -a') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getUptimeCommand(update: Update, context):
    stdin, stdout, stderr = client.exec_command('uptime') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getDfCommand(update: Update, context):
    stdin, stdout, stderr = client.exec_command('df') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info) 

def getFreeCommand(update: Update, context): #free
    stdin, stdout, stderr = client.exec_command('free') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getMpstatCommand(update: Update, context): #mpstat
    stdin, stdout, stderr = client.exec_command('mpstat') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getWCommand(update: Update, context): #w
    stdin, stdout, stderr = client.exec_command('w') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getLastCommand(update: Update, context): #Последние 10 авторизаций LAST
    stdin, stdout, stderr = client.exec_command('last -n 10') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getCritCommand(update: Update, context): #Последние 10 авторизаций LAST
    stdin, stdout, stderr = client.exec_command('journalctl -p crit -n 5') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getPsCommand(update: Update, context): #Процессы
    stdin, stdout, stderr = client.exec_command('ps auxf | head') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def getSsCommand(update: Update, context): #Порты
    stdin, stdout, stderr = client.exec_command('ss -tlu') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def AptListCommand(update: Update, context):
    update.message.reply_text('Напишите название, если вам нужен определенный пакет, иначе напишите нет')

    return 'get_apt_list'

def get_apt_list (update: Update, context):
    user_input = update.message.text # Получаем текст, содержащий нет или гназвание

    Conditions = 'нет' 
    if Conditions.upper() == user_input.upper(): # провека
        stdin, stdout, stderr = client.exec_command('apt list | head -n 11') #ввод команды
        data = stdout.read() + stderr.read()
    else:
        stdin, stdout, stderr = client.exec_command(f'apt list --all-versions {update.message.text}') #ввод команды
        data = stdout.read() + stderr.read()

    info = data.decode("utf-8")

    update.message.reply_text(info) # Отправляем сообщение пользователю
    return ConversationHandler.END # Завершаем работу обработчика диалога

def getServicesCommand(update: Update, context): #Cервисы
    stdin, stdout, stderr = client.exec_command('systemctl --type=service --state=running') #ввод команды
    data = stdout.read() + stderr.read()
    #client.close()
    info = data.decode("utf-8")
    update.message.reply_text(info)

def start(update: Update, context):
    user = update.effective_user
    update.message.reply_text(f'Привет {user.full_name}!') 


def helpCommand(update: Update, context):
    update.message.reply_text('Help!')


def findPhoneNumbersCommand(update: Update, context):
    update.message.reply_text('Введите текст для поиска телефонных номеров: ')

    return 'findPhoneNumbers'


def findEmailsCommand(update: Update, context):
    update.message.reply_text('Введите текст для поиска почты: ')

    return 'findEmail'

def verify_passwordCommand(update: Update, context):
    update.message.reply_text('Давайте проверим ваш пароль')
    return "verify_password"

def verify_password(update: Update, context): 
    user_input =  update.message.text # Получаем текст

    pass_Regex = re.compile(r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!%*#?&]{8,}$') #маска для пароля

    pass_List = pass_Regex.findall(user_input) #Проверяем условие дял нашего пароля

    if not pass_List:
        update.message.reply_text('Слабый пароль')
        return # Завершаем выполнение функции
    

    passNumbers = '' # Создаем строку, в которую будем записывать пароль
    for i in range(len(pass_List)):
        passNumbers += f'{i+1}. {pass_List[i]}\n' # Записываем пароль
        
    update.message.reply_text(passNumbers).reply_text("Сложеый пароль") # Отправляем сообщение пользователю
    return ConversationHandler.END # Завершаем работу обработчика диалога

def phone(phone_numbers, **params):
    try:
        conn = psycopg2.connect(**params)
        # Создание курсора
        cur = conn.cursor()
        
        # Проходим по каждому номеру телефона в списке
        for phone_number in phone_numbers:
            # Формирование SQL-запроса для вставки данных
            query = "INSERT INTO phone (phone) VALUES (%s);"
            
            # Выполнение SQL-запроса
            cur.execute(query, (phone_number,))
        
        # Коммит изменений
        conn.commit()
        
        print(f"Номера телефонов успешно добавлены.")
        
    except Exception as e:
        print(f"Ошибка при добавлении номеров телефонов: {e}")
    
    finally:
        # Закрытие курсора и соединения
        if cur:
            cur.close()
        if conn:
            conn.close()

def findPhoneNumbers (update: Update, context):
    user_input = update.message.text # Получаем текст, содержащий(или нет) номера телефонов

    phoneNumRegex = re.compile(r'^(?:\+7|8)?[\s(-]?\d{3}[\s)-]?\d{3}[\s-]?\d{2}[\s-]?\d{2}$') # формат для всех условий

    phoneNumberList = phoneNumRegex.findall(user_input) # Ищем номера телефонов

    if not phoneNumberList: # Обрабатываем случай, когда номеров телефонов нет
        update.message.reply_text('Телефонные номера не найдены')
        return # Завершаем выполнение функции
    
    phoneNumbers = '' # Создаем строку, в которую будем записывать номера телефонов
    for i in range(len(phoneNumberList)):
        phoneNumbers += f'{i+1}. {phoneNumberList[i]}\n' # Записываем очередной номер
        return 
    

    update.message.reply_text(phoneNumbers) # Отправляем сообщение пользователю
    update.message.reply_text('Хотите ли вы записать этот номер в базу данных?')
    
    new_user_input = update.message.text

    if str(new_user_input).upper() == "ДА":
        phone(phoneNumberList)
    return ConversationHandler.END # Завершаем работу обработчика диалога





def findEmail(update: Update, context): #Нахождение майла
    user_input = update.message.text # текст пользователя

    emailRegex = re.compile(r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$') #маска майла

    emailList = emailRegex.findall(user_input) #Ищем нужную маску в сообщении

    if not emailList: # Обрабатываем случай, когда нет эмейла
          update.message.reply_text('Почта не найдена')
          return # Завершаем выполнение функции
      
    emails = '' # Создаем строку, в которую будем записывать почту
    for i in range(len(emailList)):
        emails += f'{i+1}. {emailList[i]}\n' # Записываем почту
          
    update.message.reply_text(emails) # Отправляем сообщение пользователю
    return ConversationHandler.END # Завершаем работу обработчика диалога
      

#def echo(update: Update, context):
#update.message.reply_text(update.message.text)


def main():
    updater = Updater(TOKEN, use_context=True)

    # Получаем диспетчер для регистрации обработчиков
    dp = updater.dispatcher

    # Обработчик диалога
    convHandlerFindPhoneNumbers = ConversationHandler(
        entry_points=[CommandHandler('findPhoneNumbers', findPhoneNumbersCommand)],
        states={
            'findPhoneNumbers': [MessageHandler(Filters.text & ~Filters.command, findPhoneNumbers)],
        },
        fallbacks=[]
    )

    convHandlerFindEmails = ConversationHandler(
        entry_points=[CommandHandler('findEmail', findEmailsCommand)],
        states={
            'findEmail': [MessageHandler(Filters.text & ~Filters.command, findEmail)],
        },
        fallbacks=[]
    )

    convHandlerFindPass = ConversationHandler(
        entry_points=[CommandHandler('verify_password', verify_passwordCommand)],
        states={
            'verify_password': [MessageHandler(Filters.text & ~Filters.command, verify_password)],
        },
        fallbacks=[]
    )

    convHandlerAptList = ConversationHandler(
        entry_points=[CommandHandler('get_apt_list', AptListCommand)],
        states={
            'get_apt_list': [MessageHandler(Filters.text & ~Filters.command, get_apt_list)],
        },
        fallbacks=[]
    )

    
		
	# Регистрируем обработчики команд
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("help", helpCommand))
    dp.add_handler(convHandlerFindPhoneNumbers)
    dp.add_handler(convHandlerFindEmails)
    dp.add_handler(convHandlerFindPass)
    dp.add_handler(CommandHandler("get_release", getreleaseCommand))
    dp.add_handler(CommandHandler("get_uname", getUnameCommand))
    dp.add_handler(CommandHandler("get_uptime", getUptimeCommand))
    dp.add_handler(CommandHandler("get_df", getDfCommand))
    dp.add_handler(CommandHandler("get_free", getFreeCommand))
    dp.add_handler(CommandHandler("get_mpstat", getMpstatCommand))
    dp.add_handler(CommandHandler("get_w", getWCommand))
    dp.add_handler(CommandHandler("get_auths", getLastCommand))
    dp.add_handler(CommandHandler("get_critical", getCritCommand))
    dp.add_handler(CommandHandler("get_ps", getPsCommand))
    dp.add_handler(CommandHandler("get_ss", getSsCommand))
    dp.add_handler(convHandlerAptList)
    dp.add_handler(CommandHandler("get_services", getServicesCommand))
    dp.add_handler(CommandHandler("get_repl_logs", getrepllogs))
    dp.add_handler(CommandHandler("get_emails", getEmails))
    dp.add_handler(CommandHandler("get_phone_numbers", getPhone))

    


		
	# Регистрируем обработчик текстовых сообщений
  # dp.add_handler(MessageHandler(Filters.text & ~Filters.command, echo))
		
	# Запускаем бота getUnameCommand
    updater.start_polling()

	# Останавливаем бота при нажатии Ctrl+C
    updater.idle()


if __name__ == '__main__':
    while True:
      main()



